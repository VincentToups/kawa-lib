(define-library
    (lib shadchen-helpers)
  (export eq?* pattern-bindings-equal? all-identifiers? pattern-bindings-raw
	  reduce symbol-concat prepend-pattern ensure-string)
  (import (kawa base)
	  (kawa lib std_syntax)
	  (srfi 28)
	  (rnrs sorting (6))
	  (rnrs hashtables (6)))
  (begin

    
    
    (define eq?* (lambda (a1 . rest)
		   (memq a1 rest)))

    ;; (define (symbolically-equal? stx symbol)
    ;;   (eq? (syntax->datum stx) symbol))

    (define (sort-by-string string-predicate lst)
      (list-sort (lambda (a b)
		   (string-predicate (format "~a" a)
				     (format "~a" b)))
		 lst))
    (define (unique-symbols lst)
      (let loop ((s (sort-by-string string>? lst))
		 (acc '()))
	(cond
	 ((eq? s '()) acc)
	 ((eq? acc '())
	  (loop (cdr s)
		(cons (car s) acc)))
	 ((eq? (car s) (car acc))
	  (loop (cdr s) acc))
	 (else
	  (loop (cdr s) (cons (car s) acc))))))
    (define (mapcat f l)
      (apply append (map f l)))

    (define (length=1 lst)
      (and (not (eq? lst '()))
	   (eq? (cdr lst) '())))
    
    (define (length=2 lst)
      (and (not (eq? lst '()))
	   (not (eq? (cdr lst) '()))
	   (eq? (cdr (cdr lst)) '())))

    
    (define (pattern-bindings-raw syntax-object source-syntax)
      (define recur (lambda (syntax-object)
		      (pattern-bindings-raw syntax-object source-syntax)))
      (let ((d (syntax->datum syntax-object)))
	(cond
	 ((symbol? d) (list d))
	 ((list? d)
	  (let ((hd (car d))
		(tl (cdr d)))
	    (cond
	     ((eq?* hd 'list 'list*)
	      (mapcat recur tl))
	     ((eq?* hd 'number? 'integer? 'string? 'char? 'list? 'procedure? 'vector? 'symbol? 'char? 'hashtable?)
	      (pattern-bindings-raw (car tl) source-syntax))
	     ((eq?* hd '? 'call 'assert)
	      (pattern-bindings-raw (cadr tl) source-syntax))
	     ((eq? hd 'and)
	      (mapcat recur tl))
	     ((eq? hd 'or)
	      (pattern-bindings-raw (car tl) source-syntax))
	     ((eq? hd 'quote)
	      (list))
	     ((eq?* hd '->)
	      (pattern-bindings-raw (cadr tl) source-syntax))
	     ((eq? hd 'let)
	      (map (lambda (pair) (car pair)) tl))
	     ((and (eq? hd 'hashtable-ref)
		   (length=1 tl)
		   (symbol? (car tl)))
	      (list (car tl)))
	     ((and (eq? hd 'hashtable-ref)
		   (length=2 tl))
	      (pattern-bindings-raw (cadr tl) source-syntax))
	     ((and (eq? hd 'hashtable-ref-or)
		   (length=2 tl)
		   (symbol? (car tl)))
	      (list (car tl)))
	     ((and (eq? hd 'hashtable-ref)
		   (= (length tl) 3))
	      (pattern-bindings-raw (caddr tl) source-syntax))
	     (else (error (format "Unknown pattern head or bad syntax for head ~a from ~a" hd source-syntax))))))
	 (else '()))))
    
    (define (pattern-bindings syntax-object)
      (unique-symbols (pattern-bindings-raw syntax-object syntax-object)))

    ;; NB - l1 and l2 must be sorted if* you want set equality.
    (define (lists-of-symbols= . lists)
      (define (helper l1 l2)
	(let loop ((r1 l1)
		   (r2 l2))
	  (cond
	   ((and (eq? r1 '())
		 (eq? r2 '()))
	    #t)
	   ((eq? r1 '())
	    #f)
	   ((eq? r2 '())
	    #f)
	   ((eq? (car r1) (car r2))
	    (loop (cdr r1) (cdr r2)))
	   (else #f))))
      (let loop ((r lists))
	(cond
	 ((or (eq? r '())
	      (eq? (cdr r) '()))
	  #t)
	 ((helper (car r) (cadr r))
	  (loop (cdr r)))
	 (else #f))))
    
    (define (pattern-bindings-equal? patterns)
      (apply lists-of-symbols= (map pattern-bindings patterns)))

    (define valid-pattern-heads '(? assert number? integer? string? char? list? procedure? symbol? list vector? vector list* -> call and or quote hashtable-ref hashtable-ref-or let))
    (define (all-identifiers? syntax-list)
      (cond ((eq? syntax-list '()) #t)
	    ((identifier? (car syntax-list))
	     (all-identifiers? (cdr syntax-list)))
	    (else #f)))

    (define (ensure-string s)
	  (cond ((string? s) s)
		((symbol? s) (symbol->string s))
		(else (error "define-pattern: ensure-string: got a non-string."))))
    (define (reduce f-it-ac acc lst)
      (cond ((eq? lst '())
		 acc)
	    (else
	     (reduce f-it-ac (f-it-ac (car lst) acc) (cdr lst)))))
    (define (symbol-concat delim . symbols/strings)
      (string->symbol
       (reduce (lambda (it ac)
		 (string-append (ensure-string ac) (ensure-string delim) (ensure-string it)))
		   (car symbols/strings)
		   (cdr symbols/strings))))
    (define (prepend-pattern name-syntax)
      (datum->syntax-object
       name-syntax
       (symbol-concat "//" 'pattern (syntax->datum name-syntax))))))
